using System.Text;
using System.Text.RegularExpressions;
using XekuII.Generator.Models;
using static XekuII.Generator.Utilities.StringUtils;

namespace XekuII.Generator.Generators;

/// <summary>
/// Generates Zod validation schemas from EntityDefinition.
/// Output: {entity}.schema.generated.ts
/// </summary>
public class ZodSchemaGenerator
{
    private const string Indent = "  ";

    public string Generate(EntityDefinition entity, Dictionary<string, EntityDefinition>? entityMap = null)
    {
        var sb = new StringBuilder();
        var entityName = entity.Entity;

        // Header
        sb.AppendLine("// Auto-generated by XekuII.Generator - DO NOT EDIT");
        sb.AppendLine($"// Generated at: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        sb.AppendLine();
        sb.AppendLine("import { z } from \"zod\";");
        sb.AppendLine();

        // Create schema
        var writableFields = entity.Fields
            .Where(f => !f.Readonly || !string.IsNullOrEmpty(f.Formula))
            .ToList();

        var references = entity.Relations.Where(r => r.Type == "reference").ToList();

        sb.AppendLine($"export const create{entityName}Schema = z.object({{");

        foreach (var field in writableFields)
        {
            var chain = BuildZodChain(field, entity.Enums);
            sb.AppendLine($"{Indent}{ToCamelCase(field.Name)}: {chain},");
        }

        foreach (var rel in references)
        {
            sb.AppendLine($"{Indent}{ToCamelCase(rel.Name)}Id: z.string().uuid().nullable(),");
            sb.AppendLine($"{Indent}{ToCamelCase(rel.Name)}Name: z.string().optional().nullable(),");
        }

        sb.AppendLine("});");
        sb.AppendLine();

        // Update schema (partial)
        sb.AppendLine($"export const update{entityName}Schema = create{entityName}Schema.partial();");
        sb.AppendLine();

        // Inferred types
        sb.AppendLine($"export type Create{entityName}Input = z.infer<typeof create{entityName}Schema>;");
        sb.AppendLine($"export type Update{entityName}Input = z.infer<typeof update{entityName}Schema>;");
        sb.AppendLine();

        // Detail item schemas
        var details = entity.Relations.Where(r => r.Type == "detail").ToList();
        foreach (var detail in details)
        {
            if (entityMap == null || !entityMap.TryGetValue(detail.Target, out var targetEntity))
                continue;

            // Writable fields of target entity, excluding back-reference to parent
            var writableTargetFields = targetEntity.Fields
                .Where(f => !f.Readonly || !string.IsNullOrEmpty(f.Formula))
                .ToList();

            // Get reference relations from target entity (exclude back-reference to parent)
            var targetRefs = targetEntity.Relations
                .Where(r => r.Type == "reference" && !string.Equals(r.Target, entityName, StringComparison.OrdinalIgnoreCase))
                .ToList();

            sb.AppendLine($"export const create{detail.Target}ItemSchema = z.object({{");
            foreach (var f in writableTargetFields)
            {
                var chain = BuildZodChain(f, targetEntity.Enums);
                sb.AppendLine($"{Indent}{ToCamelCase(f.Name)}: {chain},");
            }
            // Add reference relation IDs
            foreach (var rel in targetRefs)
            {
                var refSchema = rel.Required ? "z.string().uuid()" : "z.string().uuid().nullable()";
                sb.AppendLine($"{Indent}{ToCamelCase(rel.Name)}Id: {refSchema},");
                sb.AppendLine($"{Indent}{ToCamelCase(rel.Name)}Name: z.string().optional().nullable(),");
            }
            sb.AppendLine("});");
            sb.AppendLine();

            sb.AppendLine($"export const update{detail.Target}ItemSchema = create{detail.Target}ItemSchema.partial();");
            sb.AppendLine();

            sb.AppendLine($"export type Create{detail.Target}ItemInput = z.infer<typeof create{detail.Target}ItemSchema>;");
            sb.AppendLine($"export type Update{detail.Target}ItemInput = z.infer<typeof update{detail.Target}ItemSchema>;");
            sb.AppendLine();
        }

        return sb.ToString();
    }

    private string BuildZodChain(FieldDefinition field, List<EnumDefinition>? enums)
    {
        var enumNames = enums?.Select(e => e.Name).ToHashSet(StringComparer.OrdinalIgnoreCase)
                        ?? new HashSet<string>();

        var baseType = field.Type.ToLower() switch
        {
            "string" => "z.string()",
            "int" => "z.number().int()",
            "decimal" => "z.number()",
            "double" => "z.number()",
            "bool" => "z.boolean()",
            "datetime" => "z.string()",
            "guid" => "z.string().uuid()",
            _ when enumNames.Contains(field.Type) => "z.number().int()",
            _ => "z.unknown()",
        };

        var chain = baseType;

        // Required
        if (field.Required && field.Type.ToLower() == "string")
        {
            chain += ".min(1, \"Required\")";
        }

        // Length
        if (field.Length.HasValue && field.Type.ToLower() == "string")
        {
            chain += $".max({field.Length.Value})";
        }

        // Validations
        foreach (var v in field.Validations)
        {
            chain += BuildValidationChain(v);
        }

        return chain;
    }

    private string BuildValidationChain(ValidationRule v)
    {
        var sb = new StringBuilder();
        var msg = v.Message != null ? $", \"{EscapeString(v.Message)}\"" : "";

        if (!string.IsNullOrEmpty(v.Range))
        {
            var range = v.Range;
            var gtMatch = Regex.Match(range, @"^>=?\s*(-?\d+\.?\d*)$");
            var ltMatch = Regex.Match(range, @"^<=?\s*(-?\d+\.?\d*)$");
            var rangeMatch = Regex.Match(range, @"^(-?\d+\.?\d*)\s*-\s*(-?\d+\.?\d*)$");

            if (gtMatch.Success)
            {
                var value = gtMatch.Groups[1].Value;
                var method = range.Contains(">=") ? "gte" : "gt";
                sb.Append($".{method}({value}{msg})");
            }
            else if (ltMatch.Success)
            {
                var value = ltMatch.Groups[1].Value;
                var method = range.Contains("<=") ? "lte" : "lt";
                sb.Append($".{method}({value}{msg})");
            }
            else if (rangeMatch.Success)
            {
                var min = rangeMatch.Groups[1].Value;
                var max = rangeMatch.Groups[2].Value;
                sb.Append($".gte({min}{msg}).lte({max}{msg})");
            }
        }

        if (v.Min.HasValue)
            sb.Append($".gte({v.Min.Value}{msg})");
        if (v.Max.HasValue)
            sb.Append($".lte({v.Max.Value}{msg})");

        if (!string.IsNullOrEmpty(v.Regex))
        {
            sb.Append($".regex(/{v.Regex}/{msg})");
        }

        return sb.ToString();
    }

}
