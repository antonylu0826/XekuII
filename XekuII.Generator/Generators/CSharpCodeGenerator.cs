using System.Text;
using System.Text.RegularExpressions;
using XekuII.Generator.Models;

namespace XekuII.Generator.Generators;

/// <summary>
/// Generates XAF Business Object C# code from EntityDefinition.
/// Supports: Fields, Relations, Calculated Properties, Validation Rules, Enums, and Descriptions.
/// </summary>
public class CSharpCodeGenerator
{
    private const string Indent = "    ";

    // Track enum names defined in the current entity for type mapping
    private HashSet<string> _entityEnumNames = new();

    /// <summary>
    /// Generate complete C# file content for an entity.
    /// </summary>
    public string Generate(
        EntityDefinition entity,
        string targetNamespace = "XekuII.Generated",
        List<ReverseAssociationInfo>? reverseAssociations = null,
        Dictionary<string, string>? associationNameOverrides = null)
    {
        var sb = new StringBuilder();

        // Build enum names set for type mapping
        _entityEnumNames = entity.Enums?.Select(e => e.Name).ToHashSet(StringComparer.OrdinalIgnoreCase) ?? new();

        // File header
        sb.AppendLine("// Auto-generated by XekuII.Generator - DO NOT EDIT");
        sb.AppendLine("// Generated at: " + DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"));
        sb.AppendLine();

        // Usings
        sb.AppendLine("using System.ComponentModel;");
        sb.AppendLine("using DevExpress.ExpressApp;");
        sb.AppendLine("using DevExpress.ExpressApp.DC;");
        sb.AppendLine("using DevExpress.ExpressApp.Model;");
        sb.AppendLine("using DevExpress.Persistent.Base;");
        sb.AppendLine("using DevExpress.Persistent.BaseImpl;");
        sb.AppendLine("using DevExpress.Persistent.Validation;");
        sb.AppendLine("using DevExpress.Xpo;");
        sb.AppendLine();

        // Namespace
        sb.AppendLine($"namespace {targetNamespace};");
        sb.AppendLine();

        // Generate Enums first (before the class)
        if (entity.Enums != null && entity.Enums.Count > 0)
        {
            foreach (var enumDef in entity.Enums)
            {
                GenerateEnum(sb, enumDef);
            }
        }

        // Class attributes
        sb.AppendLine("[DefaultClassOptions]");
        if (!string.IsNullOrEmpty(entity.Icon))
            sb.AppendLine($"[ImageName(\"{entity.Icon}\")]");
        if (!string.IsNullOrEmpty(entity.Caption))
            sb.AppendLine($"[XafDisplayName(\"{entity.Caption}\")]");
        if (!string.IsNullOrEmpty(entity.Description))
            sb.AppendLine($"[Description(\"{EscapeString(entity.Description)}\")]");

        // Class declaration
        sb.AppendLine($"public partial class {entity.Entity} : BaseObject");
        sb.AppendLine("{");

        // Constructor
        sb.AppendLine($"{Indent}public {entity.Entity}(Session session) : base(session) {{ }}");
        sb.AppendLine();

        // Fields
        foreach (var field in entity.Fields)
        {
            GenerateField(sb, field);
        }

        // Relations
        foreach (var relation in entity.Relations)
        {
            GenerateRelation(sb, relation, entity.Entity, associationNameOverrides);
        }

        // Reverse associations (auto-generated from other entities)
        if (reverseAssociations != null)
        {
            var existingRelationNames = entity.Relations
                .Select(r => r.Name)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);

            foreach (var reverse in reverseAssociations)
            {
                if (existingRelationNames.Contains(reverse.PropertyName))
                    continue;

                GenerateReverseAssociation(sb, reverse);
            }
        }

        // Partial methods for rules
        foreach (var rule in entity.Rules)
        {
            sb.AppendLine($"{Indent}partial void {rule.Script}();");
            sb.AppendLine();
        }

        // AfterConstruction override for default values
        GenerateAfterConstruction(sb, entity);

        // OnSaving override if there are BeforeSave rules
        var beforeSaveRules = entity.Rules.Where(r => r.Trigger == "BeforeSave").ToList();
        if (beforeSaveRules.Any())
        {
            sb.AppendLine($"{Indent}protected override void OnSaving()");
            sb.AppendLine($"{Indent}{{");
            sb.AppendLine($"{Indent}{Indent}base.OnSaving();");
            foreach (var rule in beforeSaveRules)
            {
                sb.AppendLine($"{Indent}{Indent}{rule.Script}();");
            }
            sb.AppendLine($"{Indent}}}");
            sb.AppendLine();
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// Generate an enum definition with Description attributes for AI agents.
    /// </summary>
    private void GenerateEnum(StringBuilder sb, EnumDefinition enumDef)
    {
        // Enum description
        if (!string.IsNullOrEmpty(enumDef.Description))
            sb.AppendLine($"[Description(\"{EscapeString(enumDef.Description)}\")]");

        sb.AppendLine($"public enum {enumDef.Name}");
        sb.AppendLine("{");

        for (int i = 0; i < enumDef.Members.Count; i++)
        {
            var member = enumDef.Members[i];
            var isLast = i == enumDef.Members.Count - 1;

            // Member description (for AI agents)
            if (!string.IsNullOrEmpty(member.Description))
                sb.AppendLine($"{Indent}[Description(\"{EscapeString(member.Description)}\")]");

            // Member label (for XAF UI)
            if (!string.IsNullOrEmpty(member.Label))
                sb.AppendLine($"{Indent}[XafDisplayName(\"{member.Label}\")]");

            // Member definition
            if (member.Value.HasValue)
            {
                sb.AppendLine($"{Indent}{member.Name} = {member.Value.Value}{(isLast ? "" : ",")}");
            }
            else
            {
                sb.AppendLine($"{Indent}{member.Name}{(isLast ? "" : ",")}");
            }
        }

        sb.AppendLine("}");
        sb.AppendLine();
    }

    private void GenerateReverseAssociation(StringBuilder sb, ReverseAssociationInfo reverse)
    {
        if (reverse.IsCollection)
        {
            sb.AppendLine($"{Indent}[Association(\"{reverse.AssociationName}\")]");
            sb.AppendLine($"{Indent}public XPCollection<{reverse.SourceEntity}> {reverse.PropertyName}");
            sb.AppendLine($"{Indent}{{");
            sb.AppendLine($"{Indent}{Indent}get => GetCollection<{reverse.SourceEntity}>(nameof({reverse.PropertyName}));");
            sb.AppendLine($"{Indent}}}");
        }
        else
        {
            var backingField = $"_{char.ToLower(reverse.PropertyName[0])}{reverse.PropertyName[1..]}";
            sb.AppendLine($"{Indent}private {reverse.SourceEntity} {backingField};");
            sb.AppendLine($"{Indent}[Association(\"{reverse.AssociationName}\")]");
            sb.AppendLine($"{Indent}public {reverse.SourceEntity} {reverse.PropertyName}");
            sb.AppendLine($"{Indent}{{");
            sb.AppendLine($"{Indent}{Indent}get => {backingField};");
            sb.AppendLine($"{Indent}{Indent}set => SetPropertyValue(nameof({reverse.PropertyName}), ref {backingField}, value);");
            sb.AppendLine($"{Indent}}}");
        }
        sb.AppendLine();
    }

    private void GenerateField(StringBuilder sb, FieldDefinition field)
    {
        var csharpType = MapType(field.Type);

        bool isCalculated = !string.IsNullOrEmpty(field.Formula);
        string calculationType = field.CalculationType?.ToLower() ?? "persistent";

        if (isCalculated)
        {
            GenerateCalculatedField(sb, field, csharpType, calculationType);
        }
        else
        {
            GenerateRegularField(sb, field, csharpType);
        }
    }

    /// <summary>
    /// Generate a calculated property using PersistentAlias or getter-only property.
    /// </summary>
    private void GenerateCalculatedField(StringBuilder sb, FieldDefinition field, string csharpType, string calculationType)
    {
        // Description for AI agents
        if (!string.IsNullOrEmpty(field.Description))
            sb.AppendLine($"{Indent}[Description(\"{EscapeString(field.Description)}\")]");

        // Label attribute
        if (!string.IsNullOrEmpty(field.Label))
            sb.AppendLine($"{Indent}[XafDisplayName(\"{field.Label}\")]");

        if (calculationType == "persistent")
        {
            sb.AppendLine($"{Indent}[PersistentAlias(\"{EscapeString(field.Formula!)}\")]");
            sb.AppendLine($"{Indent}public {csharpType} {field.Name}");
            sb.AppendLine($"{Indent}{{");
            sb.AppendLine($"{Indent}{Indent}get => ({csharpType})EvaluateAlias(nameof({field.Name}));");
            sb.AppendLine($"{Indent}}}");
        }
        else
        {
            sb.AppendLine($"{Indent}[NonPersistent]");
            sb.AppendLine($"{Indent}public {csharpType} {field.Name}");
            sb.AppendLine($"{Indent}{{");
            sb.AppendLine($"{Indent}{Indent}get => {field.Formula};");
            sb.AppendLine($"{Indent}}}");
        }
        sb.AppendLine();
    }

    /// <summary>
    /// Generate a regular persistent field with optional validation rules.
    /// </summary>
    private void GenerateRegularField(StringBuilder sb, FieldDefinition field, string csharpType)
    {
        var backingField = $"_{char.ToLower(field.Name[0])}{field.Name[1..]}";

        // Backing field
        sb.AppendLine($"{Indent}private {csharpType} {backingField};");

        // Description for AI agents (first attribute)
        if (!string.IsNullOrEmpty(field.Description))
            sb.AppendLine($"{Indent}[Description(\"{EscapeString(field.Description)}\")]");

        // Validation attributes
        if (field.Required)
            sb.AppendLine($"{Indent}[RuleRequiredField]");

        GenerateValidationAttributes(sb, field);

        // Other attributes
        if (field.Readonly)
            sb.AppendLine($"{Indent}[ModelDefault(\"AllowEdit\", \"False\")]");
        if (field.Length.HasValue && field.Type.ToLower() == "string")
            sb.AppendLine($"{Indent}[Size({field.Length.Value})]");
        if (!string.IsNullOrEmpty(field.Label))
            sb.AppendLine($"{Indent}[XafDisplayName(\"{field.Label}\")]");

        // Property
        sb.AppendLine($"{Indent}public {csharpType} {field.Name}");
        sb.AppendLine($"{Indent}{{");
        sb.AppendLine($"{Indent}{Indent}get => {backingField};");
        sb.AppendLine($"{Indent}{Indent}set => SetPropertyValue(nameof({field.Name}), ref {backingField}, value);");
        sb.AppendLine($"{Indent}}}");
        sb.AppendLine();
    }

    /// <summary>
    /// Generate XAF validation rule attributes based on ValidationRule definitions.
    /// </summary>
    private void GenerateValidationAttributes(StringBuilder sb, FieldDefinition field)
    {
        if (field.Validations == null || field.Validations.Count == 0)
            return;

        int ruleIndex = 0;
        foreach (var validation in field.Validations)
        {
            string ruleId = $"{field.Name}_Rule{ruleIndex++}";

            if (!string.IsNullOrEmpty(validation.Range))
            {
                GenerateRangeValidation(sb, field.Name, ruleId, validation);
            }
            else if (validation.Min.HasValue || validation.Max.HasValue)
            {
                GenerateMinMaxValidation(sb, field.Name, ruleId, validation);
            }

            if (!string.IsNullOrEmpty(validation.Regex))
            {
                GenerateRegexValidation(sb, field.Name, ruleId, validation);
            }

            if (!string.IsNullOrEmpty(validation.Criteria))
            {
                GenerateCriteriaValidation(sb, field.Name, ruleId, validation);
            }
        }
    }

    private void GenerateRangeValidation(StringBuilder sb, string fieldName, string ruleId, ValidationRule validation)
    {
        var range = validation.Range!;
        var message = validation.Message ?? $"{fieldName} 數值超出範圍";

        var gtMatch = Regex.Match(range, @"^>=?\s*(-?\d+\.?\d*)$");
        var ltMatch = Regex.Match(range, @"^<=?\s*(-?\d+\.?\d*)$");
        var rangeMatch = Regex.Match(range, @"^(-?\d+\.?\d*)\s*-\s*(-?\d+\.?\d*)$");

        if (gtMatch.Success)
        {
            var value = gtMatch.Groups[1].Value;
            var op = range.Contains(">=") ? "GreaterThanOrEqual" : "GreaterThan";
            sb.AppendLine($"{Indent}[RuleValueComparison(\"{ruleId}\", DefaultContexts.Save, ValueComparisonType.{op}, {value}, CustomMessageTemplate = \"{EscapeString(message)}\")]");
        }
        else if (ltMatch.Success)
        {
            var value = ltMatch.Groups[1].Value;
            var op = range.Contains("<=") ? "LessThanOrEqual" : "LessThan";
            sb.AppendLine($"{Indent}[RuleValueComparison(\"{ruleId}\", DefaultContexts.Save, ValueComparisonType.{op}, {value}, CustomMessageTemplate = \"{EscapeString(message)}\")]");
        }
        else if (rangeMatch.Success)
        {
            var min = rangeMatch.Groups[1].Value;
            var max = rangeMatch.Groups[2].Value;
            sb.AppendLine($"{Indent}[RuleRange(\"{ruleId}\", DefaultContexts.Save, {min}, {max}, CustomMessageTemplate = \"{EscapeString(message)}\")]");
        }
    }

    private void GenerateMinMaxValidation(StringBuilder sb, string fieldName, string ruleId, ValidationRule validation)
    {
        var message = validation.Message ?? $"{fieldName} 數值不符合要求";

        if (validation.Min.HasValue && validation.Max.HasValue)
        {
            sb.AppendLine($"{Indent}[RuleRange(\"{ruleId}\", DefaultContexts.Save, {validation.Min.Value}, {validation.Max.Value}, CustomMessageTemplate = \"{EscapeString(message)}\")]");
        }
        else if (validation.Min.HasValue)
        {
            sb.AppendLine($"{Indent}[RuleValueComparison(\"{ruleId}\", DefaultContexts.Save, ValueComparisonType.GreaterThanOrEqual, {validation.Min.Value}, CustomMessageTemplate = \"{EscapeString(message)}\")]");
        }
        else if (validation.Max.HasValue)
        {
            sb.AppendLine($"{Indent}[RuleValueComparison(\"{ruleId}\", DefaultContexts.Save, ValueComparisonType.LessThanOrEqual, {validation.Max.Value}, CustomMessageTemplate = \"{EscapeString(message)}\")]");
        }
    }

    private void GenerateRegexValidation(StringBuilder sb, string fieldName, string ruleId, ValidationRule validation)
    {
        var message = validation.Message ?? $"{fieldName} 格式不正確";
        var pattern = EscapeString(validation.Regex!);
        sb.AppendLine($"{Indent}[RuleRegularExpression(\"{ruleId}\", DefaultContexts.Save, @\"{pattern}\", CustomMessageTemplate = \"{EscapeString(message)}\")]");
    }

    private void GenerateCriteriaValidation(StringBuilder sb, string fieldName, string ruleId, ValidationRule validation)
    {
        var message = validation.Message ?? $"{fieldName} 不符合條件";
        var criteria = EscapeString(validation.Criteria!);
        sb.AppendLine($"{Indent}[RuleCriteria(\"{ruleId}\", DefaultContexts.Save, \"{criteria}\", CustomMessageTemplate = \"{EscapeString(message)}\")]");
    }

    private void GenerateRelation(StringBuilder sb, RelationDefinition relation, string currentEntity, Dictionary<string, string>? associationNameOverrides)
    {
        string associationName = $"{currentEntity}-{relation.Name}";
        if (associationNameOverrides != null && associationNameOverrides.TryGetValue(relation.Name, out var overrideName))
        {
            associationName = overrideName;
        }

        if (relation.Type == "reference")
        {
            var backingField = $"_{char.ToLower(relation.Name[0])}{relation.Name[1..]}";
            sb.AppendLine($"{Indent}private {relation.Target} {backingField};");

            // Description for AI agents
            if (!string.IsNullOrEmpty(relation.Description))
                sb.AppendLine($"{Indent}[Description(\"{EscapeString(relation.Description)}\")]");

            if (relation.Required)
                sb.AppendLine($"{Indent}[RuleRequiredField]");
            if (!string.IsNullOrEmpty(relation.Label))
                sb.AppendLine($"{Indent}[XafDisplayName(\"{relation.Label}\")]");
            sb.AppendLine($"{Indent}[Association(\"{associationName}\")]");

            sb.AppendLine($"{Indent}public {relation.Target} {relation.Name}");
            sb.AppendLine($"{Indent}{{");
            sb.AppendLine($"{Indent}{Indent}get => {backingField};");
            sb.AppendLine($"{Indent}{Indent}set => SetPropertyValue(nameof({relation.Name}), ref {backingField}, value);");
            sb.AppendLine($"{Indent}}}");
        }
        else if (relation.Type == "detail")
        {
            // Description for AI agents
            if (!string.IsNullOrEmpty(relation.Description))
                sb.AppendLine($"{Indent}[Description(\"{EscapeString(relation.Description)}\")]");

            if (!string.IsNullOrEmpty(relation.Label))
                sb.AppendLine($"{Indent}[XafDisplayName(\"{relation.Label}\")]");
            sb.AppendLine($"{Indent}[Association(\"{associationName}\"), DevExpress.Xpo.Aggregated]");

            sb.AppendLine($"{Indent}public XPCollection<{relation.Target}> {relation.Name}");
            sb.AppendLine($"{Indent}{{");
            sb.AppendLine($"{Indent}{Indent}get => GetCollection<{relation.Target}>(nameof({relation.Name}));");
            sb.AppendLine($"{Indent}}}");
        }
        sb.AppendLine();
    }

    /// <summary>
    /// Map YAML type to C# type. Supports built-in types and entity-defined enums.
    /// </summary>
    private string MapType(string yamlType)
    {
        // Check if it's an enum defined in this entity
        if (_entityEnumNames.Contains(yamlType))
        {
            return yamlType;
        }

        return yamlType.ToLower() switch
        {
            "string" => "string",
            "int" => "int",
            "decimal" => "decimal",
            "datetime" => "DateTime",
            "bool" => "bool",
            "guid" => "Guid",
            _ => yamlType // Return as-is for custom types/enums
        };
    }

    /// <summary>
    /// Generate AfterConstruction override for setting default values.
    /// </summary>
    private void GenerateAfterConstruction(StringBuilder sb, EntityDefinition entity)
    {
        // Collect fields with default values (excluding calculated fields)
        var fieldsWithDefaults = entity.Fields
            .Where(f => !string.IsNullOrEmpty(f.Default) && string.IsNullOrEmpty(f.Formula))
            .ToList();

        if (fieldsWithDefaults.Count == 0)
            return;

        sb.AppendLine($"{Indent}public override void AfterConstruction()");
        sb.AppendLine($"{Indent}{{");
        sb.AppendLine($"{Indent}{Indent}base.AfterConstruction();");

        foreach (var field in fieldsWithDefaults)
        {
            var defaultValue = ConvertDefaultValue(field.Default!, field.Type);
            sb.AppendLine($"{Indent}{Indent}{field.Name} = {defaultValue};");
        }

        sb.AppendLine($"{Indent}}}");
        sb.AppendLine();
    }

    /// <summary>
    /// Convert YAML default value to C# expression.
    /// Supports: bool, int, decimal, string, DateTime, and enum values.
    /// </summary>
    private string ConvertDefaultValue(string defaultValue, string fieldType)
    {
        var lowerType = fieldType.ToLower();
        var trimmedValue = defaultValue.Trim();

        // Handle DateTime expressions
        if (lowerType == "datetime")
        {
            // Support common DateTime expressions
            if (trimmedValue.Equals("DateTime.Now", StringComparison.OrdinalIgnoreCase) ||
                trimmedValue.Equals("now", StringComparison.OrdinalIgnoreCase))
            {
                return "DateTime.Now";
            }
            if (trimmedValue.Equals("DateTime.Today", StringComparison.OrdinalIgnoreCase) ||
                trimmedValue.Equals("today", StringComparison.OrdinalIgnoreCase))
            {
                return "DateTime.Today";
            }
            if (trimmedValue.Equals("DateTime.UtcNow", StringComparison.OrdinalIgnoreCase) ||
                trimmedValue.Equals("utcnow", StringComparison.OrdinalIgnoreCase))
            {
                return "DateTime.UtcNow";
            }
            // Return as-is for other DateTime expressions
            return trimmedValue;
        }

        // Handle bool
        if (lowerType == "bool")
        {
            return trimmedValue.ToLower() == "true" ? "true" : "false";
        }

        // Handle int
        if (lowerType == "int")
        {
            return trimmedValue;
        }

        // Handle decimal - ensure 'm' suffix
        if (lowerType == "decimal")
        {
            if (!trimmedValue.EndsWith("m", StringComparison.OrdinalIgnoreCase))
            {
                return trimmedValue + "m";
            }
            return trimmedValue;
        }

        // Handle Guid
        if (lowerType == "guid")
        {
            if (trimmedValue.Equals("Guid.Empty", StringComparison.OrdinalIgnoreCase) ||
                trimmedValue.Equals("empty", StringComparison.OrdinalIgnoreCase))
            {
                return "Guid.Empty";
            }
            if (trimmedValue.Equals("Guid.NewGuid()", StringComparison.OrdinalIgnoreCase) ||
                trimmedValue.Equals("new", StringComparison.OrdinalIgnoreCase))
            {
                return "Guid.NewGuid()";
            }
            return trimmedValue;
        }

        // Handle string
        if (lowerType == "string")
        {
            // If already quoted, use as-is
            if (trimmedValue.StartsWith("\"") && trimmedValue.EndsWith("\""))
            {
                return trimmedValue;
            }
            return $"\"{EscapeString(trimmedValue)}\"";
        }

        // Handle enum (custom types) - assume it's an enum member name
        if (_entityEnumNames.Contains(fieldType))
        {
            // If already prefixed with enum type, use as-is
            if (trimmedValue.Contains('.'))
            {
                return trimmedValue;
            }
            return $"{fieldType}.{trimmedValue}";
        }

        // Default: return as-is (for other custom types or expressions)
        return trimmedValue;
    }

    /// <summary>
    /// Escape special characters in strings for C# string literals.
    /// </summary>
    private string EscapeString(string input)
    {
        return input
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"");
    }
}
