using System.Text;
using XekuII.Generator.Models;
using static XekuII.Generator.Utilities.StringUtils;

namespace XekuII.Generator.Generators;

/// <summary>
/// Generates TypeScript type definitions from EntityDefinition.
/// Output: {entity}.types.generated.ts
/// </summary>
public class TypeScriptTypeGenerator
{
    private const string Indent = "  ";

    public string Generate(EntityDefinition entity, Dictionary<string, EntityDefinition>? entityMap = null)
    {
        var sb = new StringBuilder();
        var entityName = entity.Entity;

        // Header
        sb.AppendLine("// Auto-generated by XekuII.Generator - DO NOT EDIT");
        sb.AppendLine($"// Generated at: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        sb.AppendLine();

        // Enums
        if (entity.Enums is { Count: > 0 })
        {
            foreach (var enumDef in entity.Enums)
            {
                GenerateEnum(sb, enumDef);
            }
        }

        // Main interface
        if (!string.IsNullOrEmpty(entity.Description))
            sb.AppendLine($"/** {entity.Description} */");
        sb.AppendLine($"export interface {entityName} {{");
        sb.AppendLine($"{Indent}id: string;");

        foreach (var field in entity.Fields)
        {
            var tsType = MapType(field.Type, entity.Enums);
            var comment = !string.IsNullOrEmpty(field.Description)
                ? $" /** {field.Description} */"
                : "";
            sb.AppendLine($"{Indent}{ToCamelCase(field.Name)}: {tsType};{comment}");
        }

        foreach (var relation in entity.Relations.Where(r => r.Type == "reference"))
        {
            var refType = $"{relation.Target}Ref";
            sb.AppendLine($"{Indent}{ToCamelCase(relation.Name)}: {refType} | null;");
        }

        sb.AppendLine("}");
        sb.AppendLine();

        // Reference DTOs
        var refTargets = entity.Relations
            .Where(r => r.Type == "reference")
            .Select(r => r.Target)
            .Distinct()
            .ToList();

        foreach (var target in refTargets)
        {
            var lookupField = entity.Relations
                .First(r => r.Target == target && r.Type == "reference")
                .LookupField ?? "name";

            sb.AppendLine($"export interface {target}Ref {{");
            sb.AppendLine($"{Indent}id: string;");
            sb.AppendLine($"{Indent}{ToCamelCase(lookupField)}: string;");
            sb.AppendLine("}");
            sb.AppendLine();
        }

        // Details interface (with detail collections)
        var details = entity.Relations.Where(r => r.Type == "detail").ToList();
        if (details.Count > 0)
        {
            sb.AppendLine($"export interface {entityName}Details extends {entityName} {{");
            foreach (var detail in details)
            {
                sb.AppendLine($"{Indent}{ToCamelCase(detail.Name)}: {detail.Target}Summary[];");
            }
            sb.AppendLine("}");
            sb.AppendLine();

            foreach (var detail in details)
            {
                var targetEntity = entityMap != null && entityMap.TryGetValue(detail.Target, out var te) ? te : null;

                // Generate target entity enums if available (needed for field types)
                if (targetEntity?.Enums is { Count: > 0 })
                {
                    foreach (var enumDef in targetEntity.Enums)
                    {
                        // Avoid duplicate: only generate if not already in parent entity
                        if (entity.Enums?.Any(e => e.Name == enumDef.Name) != true)
                        {
                            GenerateEnum(sb, enumDef);
                        }
                    }
                }

                // Summary interface - full fields from target entity
                sb.AppendLine($"export interface {detail.Target}Summary {{");
                sb.AppendLine($"{Indent}id: string;");
                if (targetEntity != null)
                {
                    foreach (var f in targetEntity.Fields)
                    {
                        var tsType = MapType(f.Type, targetEntity.Enums);
                        sb.AppendLine($"{Indent}{ToCamelCase(f.Name)}: {tsType};");
                    }
                    // Include reference fields (exclude back-reference to parent)
                    var targetRefs = targetEntity.Relations
                        .Where(r => r.Type == "reference" && !string.Equals(r.Target, entity.Entity, StringComparison.OrdinalIgnoreCase))
                        .ToList();
                    foreach (var rel in targetRefs)
                    {
                        sb.AppendLine($"{Indent}{ToCamelCase(rel.Name)}Id: string;");
                        sb.AppendLine($"{Indent}{ToCamelCase(rel.Name)}Name: string | null;");
                    }
                }
                sb.AppendLine("}");
                sb.AppendLine();

                // Create DTO for detail item (writable fields, exclude back-reference to parent)
                if (targetEntity != null)
                {
                    var writableDetailFields = targetEntity.Fields
                        .Where(f => string.IsNullOrEmpty(f.Formula) && !f.Readonly)
                        .ToList();

                    // Get reference relations from target entity (exclude back-reference to parent)
                    var targetRefs = targetEntity.Relations
                        .Where(r => r.Type == "reference" && !string.Equals(r.Target, entityName, StringComparison.OrdinalIgnoreCase))
                        .ToList();

                    sb.AppendLine($"export interface Create{detail.Target}ItemDto {{");
                    foreach (var f in writableDetailFields)
                    {
                        var tsType = MapType(f.Type, targetEntity.Enums);
                        sb.AppendLine($"{Indent}{ToCamelCase(f.Name)}: {tsType};");
                    }
                    // Add reference relation IDs
                    foreach (var rel in targetRefs)
                    {
                        sb.AppendLine($"{Indent}{ToCamelCase(rel.Name)}Id: string | null;");
                    }
                    sb.AppendLine("}");
                    sb.AppendLine();

                    sb.AppendLine($"export interface Update{detail.Target}ItemDto {{");
                    foreach (var f in writableDetailFields)
                    {
                        var tsType = MapType(f.Type, targetEntity.Enums);
                        sb.AppendLine($"{Indent}{ToCamelCase(f.Name)}?: {tsType};");
                    }
                    // Add reference relation IDs
                    foreach (var rel in targetRefs)
                    {
                        sb.AppendLine($"{Indent}{ToCamelCase(rel.Name)}Id?: string | null;");
                    }
                    sb.AppendLine("}");
                    sb.AppendLine();
                }
            }
        }

        // Create DTO (excludes calculated + readonly fields)
        var writableFields = entity.Fields
            .Where(f => string.IsNullOrEmpty(f.Formula) && !f.Readonly)
            .ToList();

        sb.AppendLine($"export interface Create{entityName}Dto {{");
        foreach (var field in writableFields)
        {
            var tsType = MapType(field.Type, entity.Enums);
            sb.AppendLine($"{Indent}{ToCamelCase(field.Name)}: {tsType};");
        }
        foreach (var relation in entity.Relations.Where(r => r.Type == "reference"))
        {
            sb.AppendLine($"{Indent}{ToCamelCase(relation.Name)}Id: string | null;");
        }
        sb.AppendLine("}");
        sb.AppendLine();

        // Update DTO (all optional)
        sb.AppendLine($"export interface Update{entityName}Dto {{");
        foreach (var field in writableFields)
        {
            var tsType = MapType(field.Type, entity.Enums);
            sb.AppendLine($"{Indent}{ToCamelCase(field.Name)}?: {tsType};");
        }
        foreach (var relation in entity.Relations.Where(r => r.Type == "reference"))
        {
            sb.AppendLine($"{Indent}{ToCamelCase(relation.Name)}Id?: string | null;");
        }
        sb.AppendLine("}");
        sb.AppendLine();

        return sb.ToString();
    }

    private void GenerateEnum(StringBuilder sb, EnumDefinition enumDef)
    {
        // Use "as const" object pattern for erasableSyntaxOnly compatibility
        if (!string.IsNullOrEmpty(enumDef.Description))
            sb.AppendLine($"/** {enumDef.Description} */");
        sb.AppendLine($"export const {enumDef.Name} = {{");
        int autoValue = 0;
        foreach (var member in enumDef.Members)
        {
            var comment = !string.IsNullOrEmpty(member.Label) ? $" // {member.Label}" : "";
            var value = member.Value ?? autoValue;
            sb.AppendLine($"{Indent}{member.Name}: {value},{comment}");
            autoValue = value + 1;
        }
        sb.AppendLine("} as const;");
        sb.AppendLine($"export type {enumDef.Name} = (typeof {enumDef.Name})[keyof typeof {enumDef.Name}];");
        sb.AppendLine();

        // Label map for UI display
        sb.AppendLine($"export const {enumDef.Name}Labels: Record<{enumDef.Name}, string> = {{");
        autoValue = 0;
        foreach (var member in enumDef.Members)
        {
            var label = member.Label ?? member.Name;
            var value = member.Value ?? autoValue;
            sb.AppendLine($"{Indent}[{enumDef.Name}.{member.Name}]: \"{EscapeString(label)}\",");
            autoValue = value + 1;
        }
        sb.AppendLine("};");
        sb.AppendLine();
    }

    private static string MapType(string yamlType, List<EnumDefinition>? enums)
    {
        var enumNames = enums?.Select(e => e.Name).ToHashSet(StringComparer.OrdinalIgnoreCase)
                        ?? new HashSet<string>();

        if (enumNames.Contains(yamlType))
            return yamlType;

        return yamlType.ToLower() switch
        {
            "string" => "string",
            "int" => "number",
            "decimal" => "number",
            "double" => "number",
            "bool" => "boolean",
            "datetime" => "string",
            "guid" => "string",
            _ => "unknown",
        };
    }

}
